<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE composition PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<ui:composition xmlns:ui="http://java.sun.com/jsf/facelets" 
                xmlns="http://www.w3.org/1999/xhtml"
                template="./templates/MainTemplate.xhtml"
                xmlns:h="http://java.sun.com/jsf/html"
                xmlns:f="http://java.sun.com/jsf/core">

    <ui:define name="top">
        <p>${msg["main.page"]}/${msg["menu.validation"]}</p>
    </ui:define>

    <ui:define name="left">
        <ui:include src="./templates/menu.xhtml" />
    </ui:define>
    <ui:define name="content">
        <p>Strona demonstruje sposoby walidacji (sprawdzenia poprawności) danych wprowadzanych w formularzu.</p>
        <p>Standardowe komunikaty błędów zostały zastapione własnymi. Szczegóły na stronie poświęconej wersjom językowym.</p>
        <p>Każdy przykład korzysta z odrębnego formularza (<code>h:form</code>), dlatego działają one niezależnie od siebie. Poszczególne pola połączone są z właściwościami ziarna <code>SimpleValidationBean</code>.</p>
        <h:form>
            <hr />
            <p>Wymaganie wartości poprzez ustawienie atrybutu <code>required=true</code> elementu <code>h:inputText</code>. Nie określono miejsca wyświetlania komunikatu błędu, stąd w przypadku nie wypełnienia wartości domyślny komunikat zostanie dołączony na spodzie strony.</p>
            <p>Zmodyfikowany standardowy klucz komunikatu JSF: <code>javax.faces.component.UIInput.REQUIRED</code></p>
            <p>NAPIS (NIEPUSTY)<h:inputText required="true" value="#{simpleValidationBean.requiredField}"/>
                <h:commandButton value="Wyślij" /> Wartość pola: <h:outputText value="#{simpleValidationBean.requiredField}" />
            </p>
        </h:form>
        <hr />
        <h:form>
            <p>Wymaganie tekstu o podanym zakresie długości wartości poprzez dołączenie elementu <code>f:validateLength</code> do elementu <code>h:inputText</code>. Za pomocą elementu <code>h:message</code> ze stosowną wartością atrybutu <code>for</code> wskazano miejsce wstawienia komunikatu błędu.</p>
            <p>Zmodyfikowane standardowe klucze komunikatów JSF: <code>javax.faces.validator.LengthValidator.MINIMUM javax.faces.validator.LengthValidator.MAXIMUM</code></p>
            <p>NAPIS <h:inputText id="minLengthField" value="#{simpleValidationBean.minLengthField}">
                    <f:validateLength minimum="3" maximum="13" />
                </h:inputText><h:commandButton value="Wyślij" /> Wartość pola: <h:outputText value="#{simpleValidationBean.minLengthField}" /> <h:message for="minLengthField" />
            </p>
        </h:form>
        <hr />
        <h:form>
            <p>Pole tekstowe z konwersją na typ <code>Date</code> - jawne użycie konwertera <code>f:convertDateTime</code> z określeniem formatu daty jako <code>pattern="d.M.yyyy"</code>. Konwerter ten spełnia jednocześnie funkcję walidatora, jeżeli wpisana wartość nie jest zgodna z wzorcem formatu. Za pomocą elementu <code>h:message</code> ze stosowną wartością atrybutu <code>for</code> wskazano miejsce wstawienia komunikatu błędu.</p>
            <p>Zmodyfikowane standardowe klucze komunikatów JSF: <code>javax.faces.converter.DateTimeConverter.DATE javax.faces.converter.DateTimeConverter.DATE_detail</code></p>
            <p>DATA <h:inputText id="dateField" value="#{simpleValidationBean.dateField}">
                    <f:convertDateTime pattern="d.M.yyyy" />
                </h:inputText><h:commandButton value="Wyślij" /> Wartość pola: <h:outputText value="#{simpleValidationBean.dateField}" /> <h:message for="dateField" />
            </p>
        </h:form>
        <hr />
        <h:form>
            <p>Pole tekstowe z konwersją na typ <code>int</code> - NIEJAWNE użycie konwertera dla typu prostego. Dodatkowo zastosowano walidator zakresu danych <code>f:validateLongRange</code> z określeniem zakresu przez użycie atrybutów <code>minimum="0" maximum="100"</code>. Za pomocą elementu <code>h:message</code> ze stosowną wartością atrybutu <code>for</code> wskazano miejsce wstawienia komunikatu błędu.</p>
            <p>Zmodyfikowany standardowy klucz komunikatu JSF: <code>javax.faces.validator.LongRangeValidator.NOT_IN_RANGE</code></p>
            <p>LICZBA <h:inputText id="intField" value="#{simpleValidationBean.intField}">
                    <f:validateLongRange minimum="0" maximum="100"/>    
                </h:inputText><h:commandButton value="Wyślij" /> Wartość pola: <h:outputText value="#{simpleValidationBean.intField}" /> <h:message for="intField" />
            </p>
        </h:form>
        <hr />
        <h:form>
            <p>Wymaganie tekstu pasującego do zadanego wzorca (wyrażenia regularnego) poprzez dołączenie elementu <code>f:validateRegex</code> do elementu <code>h:inputText</code>, z określeniem wzorca jako <code>pattern="^[a-z0-9_-]{3,15}$"</code> (od 3 do 15 znaków, dozwolone tylko małe litery, cyfry i podkreślnik). Za pomocą elementu <code>h:message</code> ze stosowną wartością atrybutu <code>for</code> wskazano miejsce wstawienia komunikatu błędu.</p>
            <p>Zmodyfikowane standardowe klucze komunikatów JSF: <code>javax.faces.validator.RegexValidator.NOT_MATCHED javax.faces.validator.RegexValidator.NOT_MATCHED_detail</code></p>
            <p>LOGIN <h:inputText id="loginField" value="#{simpleValidationBean.loginField}">
                    <f:validateRegex pattern="^[a-z0-9_-]{3,15}$" />
                </h:inputText><h:commandButton value="Wyślij" /> Wartość pola: <h:outputText value="#{simpleValidationBean.loginField}" /> <h:message for="loginField" />
            </p>
        </h:form>
        <hr />
        <h:form>
            
<p>Jak wyżej z tym, że określono wzorzec jako <code>pattern="^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})$"</code> (poprawny adres e-mail). Za pomocą elementu <code>h:message</code> ze stosowną wartością atrybutu <code>for</code> wskazano miejsce wstawienia komunikatu błędu.</p>
<p>EMAIL <h:inputText id="emailField" value="#{simpleValidationBean.emailField}">
                    <f:validateRegex pattern="^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})$" />
                </h:inputText><h:commandButton value="Wyślij" /> Wartość pola: <h:outputText value="#{simpleValidationBean.emailField}" /> <h:message for="emailField" />
            </p>
        </h:form>
        <hr />
        <h:form>
<p>Jak wyżej z tym, że określono wzorzec jako <code>pattern="((?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%]).{6,20})"</code> (od 6 do 20 znaków z grup: małe litery, wielkie litery, cyfry, znaki @#$% - w napisie MUSI wystąpić co najmniej jeden znak z każdej z grup). Za pomocą elementu <code>h:message</code> ze stosowną wartością atrybutu <code>for</code> wskazano miejsce wstawienia komunikatu błędu.</p>
<p>Ponadto zastosowano element <code>h:inputSecret</code> (ukrywa wpisywane znaki) zamiast <code>h:inputText</code>.</p>
<p>Określono dwa takie elementy, zaś przycisk "Wyślij" uruchamia akcję <code>simpleValidationBean.checkPasswordMatching()</code>. Metoda ta sprawdza, czy podane hasła sa identyczne; jeżeli nie, to metoda konstruuje komunikat błędu i wstawia go jako wartość elementu domyślnego komunikatu (<code>h:message for=""</code>).</p>
            <p>HASŁO <h:inputSecret id="passwordField" value="#{simpleValidationBean.passwordField}">
                    <f:validateRegex pattern="((?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%]).{6,20})" />
                </h:inputSecret> <h:message for="passwordField" />
            </p>
            <p>HASŁO (POWTÓRZ) <h:inputSecret id="passwordRepeat" value="#{simpleValidationBean.passwordRepeat}">
                    <f:validateRegex pattern="((?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%]).{6,20})" />
                </h:inputSecret> <h:message for="passwordRepeat" /></p>
            <p><h:commandButton value="Wyślij" action="#{simpleValidationBean.checkPasswordMatching()}"/> Wartość hasła: <h:outputText value="#{simpleValidationBean.passwordField}" /> <h:message for="" /> 
            </p>
        </h:form>
        <hr />
    </ui:define>

</ui:composition>
